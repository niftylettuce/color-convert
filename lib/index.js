"use strict";

var conversions = require('./conversions');

var route = require('./route');

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    return fn(args);
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    var result = fn(args); // we're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
module.exports = convert;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb252ZXJzaW9ucyIsInJlcXVpcmUiLCJyb3V0ZSIsImNvbnZlcnQiLCJtb2RlbHMiLCJPYmplY3QiLCJrZXlzIiwid3JhcFJhdyIsImZuIiwid3JhcHBlZEZuIiwiYXJncyIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiY29udmVyc2lvbiIsIndyYXBSb3VuZGVkIiwicmVzdWx0IiwibGVuIiwiaSIsIk1hdGgiLCJyb3VuZCIsImZvckVhY2giLCJmcm9tTW9kZWwiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiY2hhbm5lbHMiLCJsYWJlbHMiLCJyb3V0ZXMiLCJyb3V0ZU1vZGVscyIsInRvTW9kZWwiLCJyYXciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQU1BLGNBQWNDLFFBQVEsZUFBUixDQUFwQjs7QUFDQSxJQUFNQyxRQUFRRCxRQUFRLFNBQVIsQ0FBZDs7QUFFQSxJQUFNRSxVQUFVLEVBQWhCO0FBRUEsSUFBTUMsU0FBU0MsT0FBT0MsSUFBUCxDQUFZTixXQUFaLENBQWY7O0FBRUEsU0FBU08sT0FBVCxDQUFpQkMsRUFBakIsRUFBcUI7QUFDbkIsTUFBTUMsWUFBWSxTQUFaQSxTQUFZLENBQVNDLElBQVQsRUFBZTtBQUMvQixRQUFJQSxTQUFTQyxTQUFULElBQXNCRCxTQUFTLElBQW5DLEVBQXlDO0FBQ3ZDLGFBQU9BLElBQVA7QUFDRDs7QUFFRCxRQUFJRSxVQUFVQyxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCSCxhQUFPSSxNQUFNQyxTQUFOLENBQWdCQyxLQUFoQixDQUFzQkMsSUFBdEIsQ0FBMkJMLFNBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFPSixHQUFHRSxJQUFILENBQVA7QUFDRCxHQVZELENBRG1CLENBYW5COzs7QUFDQSxNQUFJLGdCQUFnQkYsRUFBcEIsRUFBd0I7QUFDdEJDLGNBQVVTLFVBQVYsR0FBdUJWLEdBQUdVLFVBQTFCO0FBQ0Q7O0FBRUQsU0FBT1QsU0FBUDtBQUNEOztBQUVELFNBQVNVLFdBQVQsQ0FBcUJYLEVBQXJCLEVBQXlCO0FBQ3ZCLE1BQU1DLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxJQUFULEVBQWU7QUFDL0IsUUFBSUEsU0FBU0MsU0FBVCxJQUFzQkQsU0FBUyxJQUFuQyxFQUF5QztBQUN2QyxhQUFPQSxJQUFQO0FBQ0Q7O0FBRUQsUUFBSUUsVUFBVUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QkgsYUFBT0ksTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCTCxTQUEzQixDQUFQO0FBQ0Q7O0FBRUQsUUFBTVEsU0FBU1osR0FBR0UsSUFBSCxDQUFmLENBVCtCLENBVy9CO0FBQ0E7QUFDQTs7QUFDQSxRQUFJLE9BQU9VLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsV0FBSyxJQUFJQyxNQUFNRCxPQUFPUCxNQUFqQixFQUF5QlMsSUFBSSxDQUFsQyxFQUFxQ0EsSUFBSUQsR0FBekMsRUFBOENDLEdBQTlDLEVBQW1EO0FBQ2pERixlQUFPRSxDQUFQLElBQVlDLEtBQUtDLEtBQUwsQ0FBV0osT0FBT0UsQ0FBUCxDQUFYLENBQVo7QUFDRDtBQUNGOztBQUVELFdBQU9GLE1BQVA7QUFDRCxHQXJCRCxDQUR1QixDQXdCdkI7OztBQUNBLE1BQUksZ0JBQWdCWixFQUFwQixFQUF3QjtBQUN0QkMsY0FBVVMsVUFBVixHQUF1QlYsR0FBR1UsVUFBMUI7QUFDRDs7QUFFRCxTQUFPVCxTQUFQO0FBQ0Q7O0FBRURMLE9BQU9xQixPQUFQLENBQWUscUJBQWE7QUFDMUJ0QixVQUFRdUIsU0FBUixJQUFxQixFQUFyQjtBQUVBckIsU0FBT3NCLGNBQVAsQ0FBc0J4QixRQUFRdUIsU0FBUixDQUF0QixFQUEwQyxVQUExQyxFQUFzRDtBQUNwREUsV0FBTzVCLFlBQVkwQixTQUFaLEVBQXVCRztBQURzQixHQUF0RDtBQUdBeEIsU0FBT3NCLGNBQVAsQ0FBc0J4QixRQUFRdUIsU0FBUixDQUF0QixFQUEwQyxRQUExQyxFQUFvRDtBQUNsREUsV0FBTzVCLFlBQVkwQixTQUFaLEVBQXVCSTtBQURvQixHQUFwRDtBQUlBLE1BQU1DLFNBQVM3QixNQUFNd0IsU0FBTixDQUFmO0FBQ0EsTUFBTU0sY0FBYzNCLE9BQU9DLElBQVAsQ0FBWXlCLE1BQVosQ0FBcEI7QUFFQUMsY0FBWVAsT0FBWixDQUFvQixtQkFBVztBQUM3QixRQUFNakIsS0FBS3VCLE9BQU9FLE9BQVAsQ0FBWDtBQUVBOUIsWUFBUXVCLFNBQVIsRUFBbUJPLE9BQW5CLElBQThCZCxZQUFZWCxFQUFaLENBQTlCO0FBQ0FMLFlBQVF1QixTQUFSLEVBQW1CTyxPQUFuQixFQUE0QkMsR0FBNUIsR0FBa0MzQixRQUFRQyxFQUFSLENBQWxDO0FBQ0QsR0FMRDtBQU1ELENBbkJEO0FBcUJBMkIsT0FBT0MsT0FBUCxHQUFpQmpDLE9BQWpCIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG5jb25zdCByb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGUnKTtcblxuY29uc3QgY29udmVydCA9IHt9O1xuXG5jb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcbiAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24oYXJncykge1xuICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oYXJncyk7XG4gIH07XG5cbiAgLy8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG4gIGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcbiAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5mdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGZuKGFyZ3MpO1xuXG4gICAgLy8gd2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuICAgIC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcbiAgICAvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAobGV0IGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG4gIGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcbiAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5tb2RlbHMuZm9yRWFjaChmcm9tTW9kZWwgPT4ge1xuICBjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7XG4gICAgdmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHNcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7XG4gICAgdmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzXG4gIH0pO1xuXG4gIGNvbnN0IHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG4gIGNvbnN0IHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuICByb3V0ZU1vZGVscy5mb3JFYWNoKHRvTW9kZWwgPT4ge1xuICAgIGNvbnN0IGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG4gICAgY29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuICAgIGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcbiAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuIl19